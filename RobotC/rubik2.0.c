#pragma config(Sensor, port3,  sColor,         sensorVexIQ_ColorHue)
#pragma config(Sensor, port4,  rTouch,         sensorVexIQ_LED)
#pragma config(Sensor, port5,  rT,             sensorVexIQ_LED)
#pragma config(Sensor, port7,  stopSensor,     sensorVexIQ_Touch)
#pragma config(Sensor, port8,  dSensor,        sensorVexIQ_Distance)
#pragma config(Sensor, port10, lTouch,         sensorVexIQ_LED)
#pragma config(Sensor, port11, lT,             sensorVexIQ_LED)
#pragma config(Motor,  motor1,          rPusher,       tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor2,          sMotor,        tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor9,          lPusher,       tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor12,         bMotor,        tmotorVexIQ, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int maxR = 150;
int maxL = 63;
int maxB = 110;
int testB = 100;

void testP()
{
	setMotorTarget(lPusher, 60, 110);
	waitUntilMotorStop(lPusher);
	setMotorTarget(lPusher, 1, 70);
	waitUntilMotorStop(lPusher);
}

void pushLeft(){
	setMotorTarget(lPusher, maxL, 50);
	waitUntilMotorStop(lPusher);
}

void retriveLeft(){
	setMotorTarget(lPusher, 1, 70);
	waitUntilMotorStop(lPusher);
}



void push()
{
	setMotorTarget(rPusher, maxR, 100);
	waitUntilMotorStop(rPusher);
	setMotorTarget(rPusher, 1, 100);
	waitUntilMotorStop(rPusher);
wait1Msec(100);
	pushLeft();
	wait1Msec(200);
	retriveLeft();
}

void moveBaseLeft()
{
	int target = -90;
	resetMotorEncoder(bMotor);
	moveMotorTarget(bMotor, target, -70);
	waitUntilMotorStop(bMotor);

	int current = getMotorEncoder(bMotor);
	int fix = target - current;
	int fixSpeed = 0;

	if(current > target)
	{
		fixSpeed = 10;
	} else
	{
		fixSpeed = -10;
	}

	moveMotorTarget(bMotor, fix,fixSpeed);
	waitUntilMotorStop(bMotor);
}

void moveBaseRight()
{
	int target = 90;
	resetMotorEncoder(bMotor);
	moveMotorTarget(bMotor, target, 70);
	waitUntilMotorStop(bMotor);

	int current = getMotorEncoder(bMotor);
	int fix = target - current;
	int fixSpeed = 0;

	if(current > target)
	{
		fixSpeed = -10;
	} else
	{
		fixSpeed = 10;
	}

	moveMotorTarget(bMotor, fix,fixSpeed);
	waitUntilMotorStop(bMotor);
}

void TurnDownLeft(){
	pushLeft();

	resetMotorEncoder(bMotor);
	setMotorTarget(bMotor, 113, 70);
	waitUntilMotorStop(bMotor);

	retriveLeft();
	setMotorTarget(bMotor, 90, 20);
	waitUntilMotorStop(bMotor);
	setMotorSpeed(bMotor, 0);
}

void TurnDownRight(){
	pushLeft();

	resetMotorEncoder(bMotor);
	setMotorTarget(bMotor, (testB*-1), 70);
	waitUntilMotorStop(bMotor);

	retriveLeft();

	setMotorTarget(bMotor, -90, 20);
	waitUntilMotorStop(bMotor);
	setMotorSpeed(bMotor, 0);
}

void TurnDown()
{
	resetMotorEncoder(bMotor);
	moveMotorTarget(rPusher, maxR, 70);
	waitUntilMotorStop(rPusher);

	moveMotorTarget(bMotor, 123, 70);
	waitUntilMotorStop(bMotor);

	moveMotorTarget(rPusher, maxR * -1, -70);
	waitUntilMotorStop(rPusher);

	int fix = 90 - getMotorEncoder(bMotor);

	moveMotorTarget(bMotor, fix, 20);
}

void getColorName(string &color)
{
	color = "none";
	int hue = getColorHue(sColor);
	if ((hue >= 0 && hue < 10) || (hue <= 255 && hue > 248))
	{
		color = "RED";
	}
	else if (hue >= 165 && hue <= 175)
	{
		color = "BLUE";
	}
	else if (hue >= 75 && hue <= 98)
	{
		color = "GREEN";
	}
	else if (hue >= 55 && hue <= 68)
	{
		color = "YELLOW";
	}
	else if (hue >= 180 && hue <= 215)
	{
		color = "MAGENTA";
	}
	else if (hue >= 120 && hue <= 155)
	{
		color = "CYAN";
	}
	else if (hue >= 158 && hue <= 162)
	{
		color = "WHITE";
	}

	else if (hue >= 25 && hue <= 35)
	{
		color = "ORANGE";
	}
}

char getColor(int hue)
{
	char color = 'n';
	if ((hue >= 0 && hue < 10) || (hue <= 255 && hue > 248))
	{
		color = 'R';
	}
	else if (hue >= 165 && hue <= 175)
	{
		color = 'B';
	}
	else if (hue >= 75 && hue <= 98)
	{
		color = 'G';
	}
	else if (hue >= 55 && hue <= 68)
	{
		color = 'Y';
	}
	else if (hue >= 180 && hue <= 215)
	{
		color = 'M';
	}
	else if (hue >= 120 && hue <= 155)
	{
		color = 'C';
	}
	else if (hue >= 158 && hue <= 162)
	{
		color = 'W';
	}

	else if (hue >= 25 && hue <= 35)
	{
		color = 'O';
	}

	return color;
}

char currentFace;

void moveToR()
{
	switch (currentFace)
	{
	case 'L':
		push();
		push();
		break;
	case 'F':
		push();
		break;
	case 'R':

		break;
	case 'B':
		push();
		push();
		push();
		break;
	case 'D':
		push();
		moveBaseLeft();
		break;
	case 'U':
		push();
		moveBaseRight();
		break;
	}

	currentFace = 'R';
}

void moveToU()
{
	switch (currentFace)
	{
	case 'L':
		moveBaseRight();
		push();
		break;
	case 'F':
		moveBaseRight();
		push();
		moveBaseLeft();
		break;
	case 'R':
		moveBaseRight();
		push();
		moveBaseLeft();
		moveBaseLeft();
		break;
	case 'B':
		moveBaseRight();
		push();
		moveBaseRight();
		break;
	case 'D':
		push();
		push();
		moveBaseRight();
		moveBaseRight();
		break;
	case 'U':

		break;
	}

	currentFace = 'U';
}

void moveToF()
{
	switch (currentFace)
	{
	case 'L':
		push();

		break;
	case 'F':

		break;
	case 'R':
		push();
		push();
		push();
		break;
	case 'B':
		push();
		push();

		break;
	case 'D':
		moveBaseRight();
		push();
		moveBaseLeft();
		break;
	case 'U':
		moveBaseLeft();
		push();
		moveBaseRight();
		break;
	}

	currentFace = 'F';
}
void moveToL()
{
	switch (currentFace)
	{
	case 'L':

		break;
	case 'F':
		push();
		push();
		push();
		break;
	case 'R':
		push();
		push();
		break;
	case 'B':
		push();
		break;
	case 'D':
		push();
		push();
		push();
		moveBaseRight();
		break;
	case 'U':
		push();
		push();
		push();
		moveBaseLeft();
		break;
	}

	currentFace = 'L';
}
void moveToD()
{
	switch (currentFace)
	{
	case 'L':
		moveBaseLeft();
		push();
		break;
	case 'F':
		moveBaseLeft();
		push();
		moveBaseRight();
		break;
	case 'R':
		moveBaseLeft();
		push();
		moveBaseLeft();
		moveBaseLeft();
		break;
	case 'B':
		moveBaseLeft();
		push();
		moveBaseLeft();
		break;
	case 'D':

		break;
	case 'U':
		push();
		push();
		moveBaseLeft();
		moveBaseLeft();
		break;
	}

	currentFace = 'D';
}

void moveToB()
{
	switch (currentFace)
	{
	case 'L':

		break;
	case 'F':

		break;
	case 'R':

		break;
	case 'B':

		break;
	case 'D':

		break;
	case 'U':

		break;
	}

	currentFace = 'D';
}

bool runRead = false;

void startRead()
{
	while (runRead)
	{
		int hue = getColorHue(sColor);

		char colorName = getColor(hue);
		displayCenteredBigTextLine(1, "%d" , colorName);
		displayCenteredBigTextLine(4, "%d", hue);
		switch (colorName)
		{
		case 'R':
			moveToR();
			break;
		case 'B':
			moveToU();
			break;
		case 'G':
			moveToF();
			break;
		case 'M':
			moveToL();
			break;
		case 'C':
			moveToD();
			break;
		case 'Y':
			moveToB();
			break;
		case 'W':
			break;
		case 'O':
			break;
		}
	}
}

task main()
{
	resetMotorEncoder(lPusher);
	resetMotorEncoder(rPusher);
	resetMotorEncoder(bMotor);

	while (true)
	{

		if(getBumperValue(stopSensor) == 1){
			currentFace = 'F';
			runRead = true;
			startRead();
		}

		if (getTouchLEDValue(lTouch) == 1)
		{
			TurnDownLeft();
		}

		if (getTouchLEDValue(rTouch) == 1)
		{
			//TurnDown();
			//moveBaseRight();
			TurnDownRight();

		}

		if (getTouchLEDValue(rT) == 1)
		{
			//push();
			testB = testB + 1;
			wait1Msec(50);
		}
		if (getTouchLEDValue(lT) == 1)
		{
			wait1Msec(50);
			testB = testB - 1;
		}

		int lVal = getMotorEncoder(lPusher);
		int rVal = getMotorEncoder(rPusher);
		int bVal = getMotorEncoder(bMotor);
		float sVal = getDistanceValue(dSensor);

		displayCenteredTextLine(0, "%d", lVal);
		displayCenteredTextLine(1, "%d", rVal);
		displayCenteredTextLine(2, "%f", bVal);
		displayCenteredTextLine(3, "%f", sVal);
		displayCenteredTextLine(4, "%f", testB);

		runRead = false;
	}
}
